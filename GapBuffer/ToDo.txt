+ 1.Добавить end конструктор учитывающий, что в
реальном буффере помимо символов лежат
еще остаточные \0 символы оставшиеся после
ExpandStorage(). +
+ 2.Проверить что методы begin и end вызывают конструкторы а не агрегатно инициализируют.+
+ 3.Написать тесты на конструкторы.
+ 4.Согласовать все итераторы с концептами.
+ 5.Добавить тестовые функции просто проверяющие итераторы на все функции проверки из концептов.
+ 6.Тоже самое для GapBuffer
UB 7.operator+ и operator+= может принимать отрицательные значения
8.Добавить операторы сравнения разных итераторов https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/iterators.html
+ 9.Учесть и проверить то, что некорректно в Erase возвращали следующий итератор, зачем то
 пользуясь старым для смещения на 1, который использовался в процессе удаления. +
+ 10. Заменить ссылки на указатели и добавить конструктор по умолчанию. +
11. Пояснить в документации, что \0 считается концом строки и метод end будет искать его.
UB 12. Считать для итераторов out_of_range это когда ушло дальше первого \0 символа, проверить
    все операторы смещения на такое. 
+ 13. Переработать проверку смещения, когда мы проверяем смещение в IsBelongToBuffer
 мы уже смещаем итератор, что приводит к исключению. +
+ 14. Проверка EXC_IS_OUT_OF_RANGE должна происходить по другому ведь смещение итераторов раньше начала
и дальше конца не тоже самое что указателей, итераторы выбрасывают исключения уже при сдвиге. +-
+ 15. Узнать почему data_end в тесте декремента в 1***9 стоит несколько дальше, чем следующий символ за 9. +
+ 16. Проблема в GapBuffer::operator--(int junk) состояние this объекта было изменено, а копии возвращаемой нет и
 итератор как указывал на end так и указывает и поэтому его разыменование ведёт к ошибке. +
17. Выбрасывать исключение в GapBuffer::iterator::operator* с таким случаем.
+ 18. Реализовать нормальные проверки в operator+ они не учитывают что пользователь не знает о существовании буффера
 и срабатывают только когда он попал в буффер. Однако не всё так просто, случай когда GapBuffer стоит прямо в начале и он ненулевой
 и метод begin для итератора пропустил его, тоже может быть. 
UB  19. operator+ не учитывает, что подают отрицательные числа.
+ 19.1. Учесть что можем иметь дело только с одним гэпом из n элементов.
+ 20. Не забыть про GapBuffer::iterator.
21. Дописать сообщения для тестов.
+ 22. Всё тоже самое с operator-.
+ 23. Заменить все copy на memcpy. - не оправдано.
+ 24. Сделать BelongsToBuffer и WillSkipGap тоже friend функциями, подобно IsIterOutOfRange
+ 25. После попадания в size_t отрицательного числа, сама size_t переменная становится невалидной, что нормально для operator[].
UB 26. Проверить корректно ли такое поведение для operator+ у настоящего вектора и operator-, если да, то оставить все проверки валидными и также
   добавить их в iterator, если это всё-таки UB, то убрать лишние проверки.
+  27. Добавить тест на конструирование GapBuffer с итераторов и вообще конструирование.
+ 28. Дублировать тесты для GapBuffer::iterator
29. Сделать тотальный code review
30. Добавить версию Release 
31. Сделать несколько оптимизаций с вектором, почитать книжки в этих местах.
32. Написать красивый анимированный readme, научиться делать анимации
+ 33. Написать нормальные комментарии
34. Собрать из этого библиотеку lib и dll, узнать как лучше всего делать у Эдуарда, возможно сделать header-only.
35. Сделать документацию в Doxygen.
36. Добавить Circle Ci
37. Собрать в Clion в cmake.
+ 38. Поменять все int на нормальные stdint.h
+ 39. Определить шаблонные специализации только для определенных типов в универсальных функциях для итераторов. Законспектировать
