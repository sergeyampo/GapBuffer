+ 1.Добавить end конструктор учитывающий, что в
реальном буффере помимо символов лежат
еще остаточные \0 символы оставшиеся после
ExpandStorage(). +
+ 2.Проверить что методы begin и end вызывают конструкторы а не агрегатно инициализируют.+
+- 3.Написать тесты на конструкторы.
+ 4.Согласовать все итераторы с концептами.
+ 5.Добавить тестовые функции просто проверяющие итераторы на все функции проверки из концептов.
6.Тоже самое для GapBuffer
7.operator+ и operator+= может принимать отрицательные значения
8.Добавить операторы сравнения разных итераторов https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/iterators.html
+ 9.Учесть и проверить то, что некорректно в Erase возвращали следующий итератор, зачем то
 пользуясь старым для смещения на 1, который использовался в процессе удаления. +
+ 10. Заменить ссылки на указатели и добавить конструктор по умолчанию. +
11. Пояснить в документации, что \0 считается концом строки и метод end будет искать его.
12. Считать для итераторов out_of_range это когда ушло дальше первого \0 символа, проверить
    все операторы смещения на такое. 
+ 13. Переработать проверку смещения, когда мы проверяем смещение в IsBelongToBuffer
 мы уже смещаем итератор, что приводит к исключению. +
+ 14. Проверка EXC_IS_OUT_OF_RANGE должна происходить по другому ведь смещение итераторов раньше начала
и дальше конца не тоже самое что указателей, итераторы выбрасывают исключения уже при сдвиге. +-
+ 15. Узнать почему data_end в тесте декремента в 1***9 стоит несколько дальше, чем следующий символ за 9. +
+ 16. Проблема в GapBuffer::operator--(int junk) состояние this объекта было изменено, а копии возвращаемой нет и
 итератор как указывал на end так и указывает и поэтому его разыменование ведёт к ошибке. +
17. Выбрасывать исключение в GapBuffer::iterator::operator* с таким случаем.
+ 18. Реализовать нормальные проверки в operator+ они не учитывают что пользователь не знает о существовании буффера
 и срабатывают только когда он попал в буффер. Однако не всё так просто, случай когда GapBuffer стоит прямо в начале и он ненулевой
 и метод begin для итератора пропустил его, тоже может быть. 
+- 19. operator+ не учитывает, что подают отрицательные числа.
+ 19.1. Учесть что можем иметь дело только с одним гэпом из n элементов.
+ 20. Не забыть про GapBuffer::iterator.
21. Дописать сообщения для тестов.
+ 22. Всё тоже самое с operator-.
23. Заменить все copy на memcpy
24. Сделать BelongsToBuffer и WillSkipGap тоже friend функциями, подобно IsIterOutOfRange